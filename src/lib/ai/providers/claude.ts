// Claude Provider implementation
// Uses Anthropic's Claude API via Electron IPC

import { v4 as uuid } from 'uuid';
import type {
  AIProvider,
  AIMessage,
  AIResponse,
  AIError,
  StreamCallbacks,
  StreamHandle,
  CompletionOptions,
  ExtractionOptions,
} from '../provider';

interface ClaudeAPI {
  complete: (opts: {
    messages: AIMessage[];
    system?: string;
    maxTokens?: number;
    temperature?: number;
  }) => Promise<AIResponse | AIError>;

  stream: (opts: {
    messages: AIMessage[];
    system?: string;
    maxTokens?: number;
    temperature?: number;
    streamId: string;
  }) => Promise<{ success?: boolean; error?: string }>;

  extract: <T>(opts: {
    prompt: string;
    input: string;
    schema: object;
    temperature?: number;
  }) => Promise<{ data: T; usage?: object } | AIError>;

  hasApiKey: () => Promise<boolean>;

  onStreamDelta: (callback: (data: { streamId: string; delta: string }) => void) => void;
  onStreamEnd: (callback: (data: { streamId: string }) => void) => void;
  onStreamError: (callback: (data: { streamId: string; error: string }) => void) => void;
  removeStreamListeners: () => void;
}

declare global {
  interface Window {
    canopy?: {
      claude?: ClaudeAPI;
      [key: string]: unknown;
    };
  }
}

const isElectron = typeof window !== 'undefined' && window.canopy?.claude !== undefined;

export class ClaudeProvider implements AIProvider {
  readonly name = 'Claude (Anthropic)';
  readonly id = 'claude';

  async isConfigured(): Promise<boolean> {
    if (!isElectron) return false;
    return window.canopy!.claude!.hasApiKey();
  }

  async complete(
    messages: AIMessage[],
    options: CompletionOptions = {}
  ): Promise<AIResponse | AIError> {
    if (!isElectron) {
      return this.mockComplete(messages);
    }

    const result = await window.canopy!.claude!.complete({
      messages,
      system: options.system,
      maxTokens: options.maxTokens,
      temperature: options.temperature,
    });

    return result;
  }

  stream(
    messages: AIMessage[],
    callbacks: StreamCallbacks,
    options: CompletionOptions = {}
  ): StreamHandle {
    const streamId = uuid();

    if (!isElectron) {
      this.mockStream(messages, callbacks, streamId);
      return { id: streamId, cancel: () => {} };
    }

    const claude = window.canopy!.claude!;

    // Set up listeners
    claude.onStreamDelta(({ streamId: sid, delta }) => {
      if (sid === streamId) callbacks.onDelta(delta);
    });

    claude.onStreamEnd(({ streamId: sid }) => {
      if (sid === streamId) {
        callbacks.onEnd();
        claude.removeStreamListeners();
      }
    });

    claude.onStreamError(({ streamId: sid, error }) => {
      if (sid === streamId) {
        callbacks.onError(error);
        claude.removeStreamListeners();
      }
    });

    // Start stream
    claude.stream({
      messages,
      system: options.system,
      maxTokens: options.maxTokens,
      temperature: options.temperature,
      streamId,
    });

    return {
      id: streamId,
      cancel: () => claude.removeStreamListeners(),
    };
  }

  async extract<T>(
    prompt: string,
    input: string,
    schema: object,
    options: ExtractionOptions = {}
  ): Promise<{ data: T } | AIError> {
    if (!isElectron) {
      return this.mockExtract<T>();
    }

    return window.canopy!.claude!.extract<T>({
      prompt,
      input,
      schema,
      temperature: options.temperature,
    });
  }

  // Mock implementations for web dev mode
  private async mockComplete(messages: AIMessage[]): Promise<AIResponse> {
    await new Promise(r => setTimeout(r, 500));
    const lastMessage = messages[messages.length - 1]?.content || '';
    return {
      content: `[Mock Response] You said: "${lastMessage.slice(0, 50)}..."`,
      usage: { inputTokens: 100, outputTokens: 50 },
      stopReason: 'end_turn',
    };
  }

  private async mockStream(
    _messages: AIMessage[],
    callbacks: StreamCallbacks,
    _streamId: string
  ): Promise<void> {
    const response = "This is a mock streaming response. In production, this would be generated by Claude based on your context and question.";
    const words = response.split(' ');

    for (const word of words) {
      await new Promise(r => setTimeout(r, 50));
      callbacks.onDelta(word + ' ');
    }

    callbacks.onEnd();
  }

  private async mockExtract<T>(): Promise<{ data: T }> {
    await new Promise(r => setTimeout(r, 300));
    return { data: {} as T };
  }
}

// Export singleton instance
export const claudeProvider = new ClaudeProvider();
